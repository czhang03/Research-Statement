%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% "ModernCV" CV and Cover Letter
% LaTeX Template
% Version 1.1 (9/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Xavier Danaux (xdanaux@gmail.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% Important note:
% This template requires the moderncv.cls and .sty files to be in the same
% directory as this .tex file. These files provide the resume style and themes
% used for structuring the document.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt,a4paper,sans]{moderncv} % Font sizes: 10, 11, or 12; paper sizes: a4paper, letterpaper, a5paper, legalpaper, executivepaper or landscape; font families: sans or roman

\moderncvstyle{classic} % CV theme - options include: 'casual' (default), 'classic', 'oldstyle' and 'banking'
\moderncvcolor{grey} % CV color - options include: 'blue' (default), 'orange', 'green', 'red', 'purple', 'grey' and 'black'

\usepackage{biblatex} %Imports biblatex package
\addbibresource{refs.bib} %Import the bibliography file

\makeatletter
\NewDocumentCommand{\mysubsection}{sm}{%
  \par\addvspace{1ex}%
  \phantomsection{}% reset the anchor for hyperrefs
  \addcontentsline{toc}{subsection}{#2}%
  {\strut\raggedleft\raisebox{\baseletterheight}{\color{color1}\rule{0.3\hintscolumnwidth}{0.95ex}}\quad}{\strut\subsectionstyle{#2}}%
  \par\nobreak\addvspace{.5ex}\@afterheading}% to avoid a pagebreak after the heading
\makeatother


\usepackage[scale=0.8]{geometry} % Reduce document margins
%\setlength{\hintscolumnwidth}{3cm} % Uncomment to change the width of the dates column
%\setlength{\makecvtitlenamewidth}{10cm} % For the 'classic' style, uncomment to adjust the width of the space allocated to your name

%----------------------------------------------------------------------------------------
%	NAME AND CONTACT INFORMATION SECTION
%----------------------------------------------------------------------------------------

\firstname{Cheng} % Your first name
\familyname{Zhang} % Your last name

% All information in this block is optional, comment out any lines you don't need
\title{Research Statement}
%\address{W. Ethan Eagle}{}
%\mobile{(302) 584 3464}
%\phone{(000) 111 1112}
%\fax{(000) 111 1113}
\email{czhang03@bu.edu}                               % optional, remove / comment the line if not wanted
\homepage{czhang03.github.io}              % optional, remove / comment the line if not wanted
\social[github]{czhang03}                              % optional, remove / comment the line if not wanted
\extrainfo{\faFile{}~\href{https://cdn.jsdelivr.net/gh/czhang03/CV@master/CV.pdf}{Curriculum vitae}}

%\homepage{https://czhang03.github.io/}{https://czhang03.github.io/} % The first argument is the url for the clickable link, the second argument is the url displayed in the template - this allows special characters to be displayed such as the tilde in this example
%\extrainfo{additional information}
%\photo[70pt][0.4pt]{pictures/picture} % The first bracket is the picture height, the second is the thickness of the frame around the picture (0pt for no frame)

\let\originalrecomputecvlengths\recomputecvlengths
\renewcommand*{\recomputecvlengths}{%
\originalrecomputecvlengths%
\setlength{\quotewidth}{0.85\textwidth}}
\quote{``the possibility of making explicit, elegant computations has always come out [\dots] as a byproduct of a thorough conceptual understanding\dots'' -- Alexander Grothendieck}

%----------------------------------------------------------------------------------------

\begin{document}
\makecvtitle % Print the CV title

% set spacing
\setlength\parskip{8px}
% avoid paraskip on the first paragraph
\vspace{-\parskip} 

Many challenges in computer science can be formulated as program equivalences, where we seek to establish that two programs behave similarly or identically. 
For example, the correctness of compilers and decompilers can be defined by the equivalence of the input and output programs. 
Similarly, the correctness of machine-learning model compression can be verified by the equivalence of the model's behavior before and after compression. 
The integrity of privacy and security algorithms can also be characterized by their indistinguishability from ideal scenarios. 
More surprisingly, problems like network reachability, network traffic isolation, program logic, and computational effects, can all be formalized and analyzed using equations~\cite{anderson_NetKATSemanticFoundations_2014a,zhang_IncorrectnessLogicKleene_2022,moller_AlgebraProgramCorrectness_2021,plotkin_HandlersAlgebraicEffects_2009,plotkin_AdequacyAlgebraicEffects_2001}.

While general program equivalences remain undecidable, Kleene Algebra (KA), an abstract algebraic system rooted in automata theory, has shown great promise in both proving and automating program equivalences in various domains. 
The theoretical elegance of Kleene Algebra have inspired a wealth of foundational research~\cite{smolka_GuardedKleeneAlgebra_2020,schmid_GuardedKleeneAlgebra_2021,jacobs_BialgebraicReviewDeterministic_2006,kozen_CoalgebraicTheoryKleene_2008,schmid_CoalgebraicCompletenessTheorems_2024,rozowski_ProbabilisticGuardedKAT_2023}; and the practical systems based on Kleene Algebra have excelled in compiler verification~\cite{kozen_CertificationCompilerOptimizations_2000d}, (probabilistic) network systems~\cite{anderson_NetKATSemanticFoundations_2014a,foster_CoalgebraicDecisionProcedure_2015,smolka_ScalableVerificationProbabilistic_2019,zhang_NetterProbabilisticStateful_2021}, weak memory model~\cite{kokologiannakis_KaterAutomatingWeak_2023}, and distributed systems~\cite{mciver_UsingProbabilisticKleene_2008}. 
Notably, some of these tools have matched or even outperformed state-of-the-art tools in their respective domains.

My research is nicely positioned at the intersection of theory and practice, enabling me to collaborate with researchers and students with diverse backgrounds, and produce interesting results on both sides. 
My research workflow usually involves learning about specific application domains, applying the perspective of Kleene Algebra to understand and tackle problems, and refining theoretical tooling to achieve the most elegant solutions. 
This approach has proven to be effective for me, yielding both rich theoretical frameworks and efficient tools, while also identifying promising open problems for future exploration. 
My current work has been applied to program logics~\cite{zhang_IncorrectnessLogicKleene_2022,zhang_DomainReasoningTopKAT_2024} and decompiler validation~\cite{zhang_CFGKATEfficientValidation_2025}; all published in top-tier conferences like POPL and ICALP. 
Additionally, my theoretical ventures have demonstrated the limitations of alignment reasoning in relational verification, resolved a long-standing open problem in Kleene Algebra~\cite{azevedodeamorim_KleeneAlgebraCommutativity_2024a}, developed an algebraic perspective of the reduction technique in Kleene Algebra~\cite{zhang_DomainReasoningTopKAT_2024}, and developed efficient algorithm to check the equivalence of uninterpreted programs~\cite{zhang_EfficientSymbolicAlgorithms_2025}.


\section{TopKAT: A Unified View Of Program Logic}

Incorrectness logic~\cite{ohearn_IncorrectnessLogic_2020}, although simple, has shown great potential for bug detection across various semantic domains~\cite{raad_LocalReasoningPresence_2020,le_FindingRealBugs_2022, zhang_QuantitativeStrongestPost_2022b}.
To unify the theory of incorrectness logic in these semantic domains, we tried to use Kleene algebra with tests (KAT) as an algebraic semantic foundation. 
This task was soon proven to be impossible~\cite{zhang_IncorrectnessLogicKleene_2022}: we showed that the theory of KAT is insufficient to encode incorrectness logic, mainly because KAT lacks the relational domain operation.
Surprisingly, instead of adding a fully-fledged domain operator, we only need to add a top element.
We named our framework Kleen algebra with top and tests (TopKAT), and unlike KAT extensions with domain operators~\cite{desharnais_KleeneAlgebraDomain_2006,sedlar_ComplexityKleeneAlgebra_2023}, TopKAT preserves the complexity class of KAT~\cite{zhang_IncorrectnessLogicKleene_2022}.

However, upon diving into the theory of TopKAT, we discovered its unexpected limitation: despite its power to subsume both propositional Hoare and incorrectness logic, TopKAT is incomplete with respect to its relational model. 
Our followup work~\cite{zhang_DomainReasoningTopKAT_2024} resolves this weakness by focusing on the inequalities used to encode incorrectness and Hoare logic, which we named ``domain-comparison inequalities''. 
In this work, we used techniques in universal algebra to streamline the definition of reduction~\cite{pous_ToolsCompletenessKleene_2021,kozen_KleeneAlgebraTests_1997c}.
This new perspective greatly simplified previous completeness proofs, and also allowed us to prove the relational completeness with regard domain-comparison inequalities. 
This result has not only demonstrated the effectiveness of reasoning about incorrectness and Hoare logics using TopKAT, but also other logics like reachability logic~\cite{naus_ReachabilityLogicLowLevel_2022a} as well.

\textbf{Future Works:}
There are two interesting future directions of this work.
Practically, many features of program logic can be combined to improve the theory and automation, like separation and relational reasoning. 
Specifically, separation will enable modular program reasoning, which can speed up automation. 
Relational reasoning is used in the verification cryptography and privacy. 
Addressing relational verification could develop tools that enhance the scalability of crypto-protocol verification. 
Theoretically, I want to design a general and compositional theory of reduction based on our novel algebraic notion of reduction. 
This work will greatly simplify the completeness and decidablility proofs of Kleene Algebra extensions. 

\section{CF-GKAT, control flow verification in nearly linear time}

Control-flow manipulation is a prevalent task in software engineering, thus verifying its correctness is crucial to ensure software reliability.
Our work, building upon foundational researches on guarded Kleene algebra with tests (GKAT)~\cite{smolka_GuardedKleeneAlgebra_2020} and the theory of non-local control flow in Kleene algebra~\cite{kozen_NonlocalFlowControl_2008a}, greatly simplifies process of control-flow verification.
Specifically, We extended GKAT automaton to handel common control structures, including break, return, goto, and indicator variables; while preserving its efficiency and correctness.
These extensions enable us to validate a large class of control-flow restructuring algorithms~\cite{yakdan_NoMoreGotos_2015,basque_AhoySAILRThere_,erosa_TamingControlFlow_1994,kozen_CertificationCompilerOptimizations_2000d}.
And its efficiency and correctness allow our works to be invoked automatically on-the-fly, or be used as a framework in a proof assistant.

\textbf{Future works:}
This project can evolve in several ways. 
Practically, we can enhance our implementation with symbolic techniques, introduce more control-flow structures to improve the language's expressiveness, or develop an axiomatic proof system for simpler correctness proofs of our (de)compilation algorithms.
Theoretically, we can simplify our proofs by investigating the coalgebraic theory of our systems and by adopting a modular approach to control-flow features. 
By building the system in a modular way, we can also facilitate future extensions and ensure that theoretical properties hold for each subsystem. 

\section{Efficient Symbolic On-the-fly Algorithm for GKAT}

In the process of implementing CF-GKAT, we have identified several ways to improve the efficiency of GKAT equivalences.
For example, when there is a large amount of primitive test (primitive conditional statements used in if-statement and while-loops), the memory usage and runtime of the original algorithm~\cite{smolka_GuardedKleeneAlgebra_2020} will blowup exponentially. 
The large memory usage is typically resolved using derivatives to produce the automaton on-the-fly~\cite{brzozowski_DerivativesRegularExpressions_1964, schmid_GuardedKleeneAlgebra_2021}, whereas the long runtime can be optimized using symbolic automaton~\cite{pous_SymbolicAlgorithmsLanguage_2015}. 

Our latest work marries these two ideas, and built a theory of symbolic GKAT coalgebra, where we designed several efficient symbolic equivalence-checking algorithm for GKAT. 
Unlike similar works on KAT~\cite{pous_SymbolicAlgorithmsLanguage_2015}, the structure of GKAT enables us to export the complex boolean logic into a fast and reliable solvers like z3; further improving the efficiency of our implementation.
Our rust implementation can decide large equivalences (with more than 500 commands pre expression) in seconds with only couple megabytes of memory usage.
This work also characterized the exact complexity of GKAT, which is co-NP-complete.


\section{Kleene Algebra With Commutativity Hypothesis}

Commutativity hypothesis has long been recognized for its importance in control-flow analysis~\cite{kozen_KleeneAlgebraTests_1996}, yet recent work~\cite{antonopoulos_AlgebraAlignmentRelational_2023} has also established its vital role in relational verification. 
Contrary to its broad applications, the theory of KA with commutativity hypothesis remains stale; specifically, the decidability of the theory has made no progress since the question was raised by Kozen~\cite{kozen_KleeneAlgebraTests_1996}.
Independently, Kuznetsov~\cite{kuznetsov_ComplexityReasoningKleene_2023} has shown that Kleene Algebra with commutativity is indeed undecidable. We, on the other hand, has shown the same result without using the induction or right unfolding rule~\cite{azevedodeamorim_KleeneAlgebraCommutativity_2024}. 
Our result exhibits a large class of equational theories that are all undecidable when extended commutativity hypothesis, generalizing the result of Kuznetsov.

\textbf{Future works:}
This work settles a long-standing open problem in Kleene algebra, and also demonstrates the limitation of relational reasoning with algebra of alignment~\cite{antonopoulos_AlgebraAlignmentRelational_2023}. 
Next, I seek to design a decidable algebraic theory for a restricted version of the alignment problem, and investigate its practical use cases.

\section{Other Directions}

\mysubsection{Session Type With Dynamic Information}
Session type systems provide a formal framework for specifying and verifying communication protocols between two parties, ensuring security properties such as deadlock freedom.
However, their expressiveness is limited when it comes to protocols that rely on dynamic information, such as leader election, resource allocation, and load balancing, where the subsequent actions depend on factors that are determined at runtime, like available system resources.
To address this limitation, I plan to extend session type systems with dynamic decision-making capabilities and leverage the efficient decision procedure of guarded Kleene algebra with tests (GKAT) to design type-checking algorithms for this new framework.
By combining the strengths of session types and GKAT, I believe we can develop a robust, expressive, and efficient type system that can verify complex communication protocols in a timely manner.

\mysubsection{Future, Deadlock, and Data Races}

In addition to type-based approaches to eliminate deadlock, I am also interested in detecting deadlock and data races in existing code bases without manual type annotations, particularly in systems with threads accessing a shared memory.
Traditional detection tools are often language-specific~\cite{williams_StaticDeadlockDetection_2005,masticola_StaticDetectionDeadlocks_1993,engler_RacerXEffectiveStatic_2003,naik_EffectiveStaticDeadlock_2009}, but recent graph-based techniques offer a robust alternative. 
This approach encodes a program's execution in a graph and performs deadlock and data race detection on it~\cite{muller_StaticPredictionParallel_2022,muller_ResponsiveParallelismFutures_2020,rinaldi_PipelinesGraphTypes_2024,muller_LanguageAgnosticStaticDeadlock_2024a}.
I seek to bring the (co)algebraic perspective to this line of research, leveraging Kleene Algebra to establish connections between graphs and semantics. 
This will deepen our understanding of the graph-based techniques, potentially leading to more efficient deadlock and data-race detection, as well as a formal proof system to ensure deadlock and data-race freedom.
This endeavor also requires exciting extensions to concurrent Kleene Algebra~\cite{hoare_ConcurrentKleeneAlgebra_2011,kappe_ConcurrentKleeneAlgebra_2020,kappe_ConcurrentKleeneAlgebra_2018,wagemaker_PartiallyObservableConcurrent_2020,mciver_ProbabilisticConcurrentKleene_2013}, including support for \verb|future|, a common way to construct concurrent computations in modern programming languages; and a framework for analyzing data dependencies, a key cause of deadlocks and data-races.


\newpage
\printbibliography %Prints bibliography


\end{document}
