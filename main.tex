%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% "ModernCV" CV and Cover Letter
% LaTeX Template
% Version 1.1 (9/12/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Xavier Danaux (xdanaux@gmail.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
% Important note:
% This template requires the moderncv.cls and .sty files to be in the same
% directory as this .tex file. These files provide the resume style and themes
% used for structuring the document.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[11pt,a4paper,sans]{moderncv} % Font sizes: 10, 11, or 12; paper sizes: a4paper, letterpaper, a5paper, legalpaper, executivepaper or landscape; font families: sans or roman

\moderncvstyle{classic} % CV theme - options include: 'casual' (default), 'classic', 'oldstyle' and 'banking'
\moderncvcolor{grey} % CV color - options include: 'blue' (default), 'orange', 'green', 'red', 'purple', 'grey' and 'black'

\usepackage{biblatex} %Imports biblatex package
\addbibresource{refs.bib} %Import the bibliography file

\makeatletter
\NewDocumentCommand{\mysubsection}{sm}{%
  \par\addvspace{1ex}%
  \phantomsection{}% reset the anchor for hyperrefs
  \addcontentsline{toc}{subsection}{#2}%
  {\strut\raggedleft\raisebox{\baseletterheight}{\color{color1}\rule{0.3\hintscolumnwidth}{0.95ex}}\quad}{\strut\subsectionstyle{#2}}%
  \par\nobreak\addvspace{.5ex}\@afterheading}% to avoid a pagebreak after the heading
\makeatother


\usepackage[scale=0.8]{geometry} % Reduce document margins
%\setlength{\hintscolumnwidth}{3cm} % Uncomment to change the width of the dates column
%\setlength{\makecvtitlenamewidth}{10cm} % For the 'classic' style, uncomment to adjust the width of the space allocated to your name

%----------------------------------------------------------------------------------------
%	NAME AND CONTACT INFORMATION SECTION
%----------------------------------------------------------------------------------------

\firstname{Cheng} % Your first name
\familyname{Zhang} % Your last name

% All information in this block is optional, comment out any lines you don't need
\title{Research Statement}
%\address{W. Ethan Eagle}{}
%\mobile{(302) 584 3464}
%\phone{(000) 111 1112}
%\fax{(000) 111 1113}
\email{czhang03@bu.edu}                               % optional, remove / comment the line if not wanted
\homepage{cs-people.bu.edu/czhang03/}              % optional, remove / comment the line if not wanted
\social[github]{czhang03}                              % optional, remove / comment the line if not wanted
\extrainfo{\faFile{}~\href{https://cdn.jsdelivr.net/gh/czhang03/CV@master/CV.pdf}{Curriculum vitae}}

%\homepage{https://czhang03.github.io/}{https://czhang03.github.io/} % The first argument is the url for the clickable link, the second argument is the url displayed in the template - this allows special characters to be displayed such as the tilde in this example
%\extrainfo{additional information}
%\photo[70pt][0.4pt]{pictures/picture} % The first bracket is the picture height, the second is the thickness of the frame around the picture (0pt for no frame)

\let\originalrecomputecvlengths\recomputecvlengths
\renewcommand*{\recomputecvlengths}{%
\originalrecomputecvlengths%
\setlength{\quotewidth}{0.85\textwidth}}
\quote{``the possibility of making explicit, elegant computations has always come out [\dots] as a byproduct of a thorough conceptual understanding\dots'' -- Alexander Grothendieck}

%----------------------------------------------------------------------------------------

\begin{document}
\makecvtitle % Print the CV title

% set spacing
\setlength\parskip{8px}

Many challenges in computer science can be framed as program equivalences. 
For instance, the correctness of (de)compilers can be defined by the requirement that the input program behaves identically to the output program. 
Similarly, The correctness of machine learning model compression can also be assessed through the equivalence of the model before and after compression.
The integrity of privacy and security algorithms can be characterized by the indistinguishability between their implementations and ideal scenarios. 
Furthermore, more complex issues, such as network reachability~\cite{anderson_NetKATSemanticFoundations_2014a}, traffic isolation~\cite{anderson_NetKATSemanticFoundations_2014a}, program logic~\cite{zhang_IncorrectnessLogicKleene_2022,moller_AlgebraProgramCorrectness_2021}, and computational effects~\cite{plotkin_HandlersAlgebraicEffects_2009,plotkin_AdequacyAlgebraicEffects_2001}, can also be characterized using equations.

While general program equivalences may be infeasible, there are two well-established approaches for verifying program equivalences in specific applications. 
The first, commonly referred to as the "algebraic" or "denotational" approach, constructs an equational proof system based on program behavior. T
his method enables the creation of manual equational proofs and produces abstract, reusable results. 
The second approach, known as the "coalgebraic" or "operational" approach, involves comparing the automata representations of pairs of programs. 
Although this method allows for fully automated equivalence checking in many practical scenarios, the results are typically not reusable and must be validated for each program pair. 
Excitingly, these two approaches can be combined, facilitating collaboration between humans and computers to conquer challenging problems. 
The potential of this hybrid method has inspired a wealth of foundational research~\cite{smolka_GuardedKleeneAlgebra_2020,schmid_GuardedKleeneAlgebra_2021,jacobs_BialgebraicReviewDeterministic_2006,anderson_NetKATSemanticFoundations_2014a,foster_CoalgebraicDecisionProcedure_2015,kozen_CoalgebraicTheoryKleene_2008,schmid_CoalgebraicCompletenessTheorems_2024,rozowski_ProbabilisticGuardedKAT_2023}.

My research builds upon these foundational techniques, extending them into a wide array of domains to address practical problems while advancing theoretical boundaries. 
I am passionate about collaborating with students and researchers from diverse backgrounds to tackle challenging issues in their fields, applying the (co)algebraic perspective to drive progress. 
Ultimately, many of my projects yield not only rich theoretical frameworks but also efficient tools, while leaving behind promising open problems for future exploration.

\section{TopKAT: A Unified View Of Program Logic}

Incorrectness logic~\cite{ohearn_IncorrectnessLogic_2020}, although simple, has shown great potential for bug detection across various semantical domains~\cite{raad_LocalReasoningPresence_2020,le_FindingRealBugs_2022, zhang_QuantitativeStrongestPost_2022b}.
To unify the theory of incorrectness logic in these semantical domains, we tried to use Kleene algebra with tests (KAT) as a simple and abstract semantical foundations. 
This task was soon proven to be impossible~\cite{zhang_IncorrectnessLogicKleene_2022}: we showed that the theory of KAT is insufficient to encode incorrectness logic, mainly because KAT lacks the relational domain operation.
Surprisingly, instead of adding a fully-fledged domain operator, we only need to add a top element.
We named our framework Kleen algebra with top and tests (TopKAT), and unlike KAT extensions with domain operators~\cite{desharnais_KleeneAlgebraDomain_2006,sedlar_ComplexityKleeneAlgebra_2023}, TopKAT preserves the complexity class of KAT~\cite{zhang_IncorrectnessLogicKleene_2022}.

However, upon diving into the theory of TopKAT, we discovered its unexpected limitation: despite its power to subsume both propositional Hoare and incorrectness logic, TopKAT is incomplete with respect to its relational model. 
Our followup work~\cite{zhang_DomainReasoningTopKAT_2024} resolves this weakness by focusing on the inequalities used to encode incorrectness and Hoare logic, which we named ``domain-comparison inequalities''. 
In this work, we used techniques in universal algebra to streamline the definition of reduction~\cite{pous_ToolsCompletenessKleene_2021,kozen_KleeneAlgebraTests_1997c}.
This new perspective greatly simplified previous completeness proofs, and also allowed us to prove the relational completeness with regard domain-comparison inequalities. 
This result has not only demonstrated the effectiveness of reasoning about incorrectness and Hoare logics using TopKAT, but also other logics like reachability logic~\cite{naus_ReachabilityLogicLowLevel_2022a} as well.

In the future, we plan to extend the universal algebra techniques in this work to prove more complicated completeness results. We hope this will yield another compositional framework for completeness proof in Kleene Algebra.

\section{Kleene Algebra With Commutativity Hypothesis}

Commutativity hypothesis has long been recognized for its importance in control-flow analysis~\cite{kozen_KleeneAlgebraTests_1996}, yet recent work~\cite{antonopoulos_AlgebraAlignmentRelational_2023} has also established its vital role in relational verification. 
Contrary to its broad applications, the theory of KA with commutativity hypothesis remains stale; specifically, the decidability of the theory has made no progress since the question was raised by Kozen~\cite{kozen_KleeneAlgebraTests_1996}.

Independently, Kuznetsov~\cite{kuznetsov_ComplexityReasoningKleene_2023} has shown that Kleene Algebra with commutativity is indeed undecidable. We, on the other hand, has shown the same result without using the induction or right unfolding rule~\cite{azevedodeamorim_KleeneAlgebraCommutativity_2024}. 
Our result exhibits a large class of equational theories that are all undecidable when extended commutativity hypothesis, generalizing the result of Kuznetsov.

This work settles a long-standing open problem in Kleene algebra, and also demonstrates the limitation of relational reasoning with algebra of alignment~\cite{antonopoulos_AlgebraAlignmentRelational_2023}. In fact, we envision a decidable, yet less robust, extension of Kleene Algebra useful for reasoning about alignment problems in relational verifications.

\section{CF-GKAT, control flow verification in nearly linear time}

Control-flow manipulation is a prevalent task in software engineering, thus verifying its correctness is crucial to ensure software reliability.
Our work, building upon foundational researches on guarded Kleene algebra with tests (GKAT)~\cite{smolka_GuardedKleeneAlgebra_2020} and the theory of non-local control flow in Kleene algebra~\cite{kozen_NonlocalFlowControl_2008a}, greatly simplifies process of control-flow verification.

Specifically, We extended GKAT with common control structures, including break, return, goto, and indicator variables; while preserving its efficiency, soundness, and completeness.
These extensions enable us to verify a large class of control-flow restructuring algorithms~\cite{yakdan_NoMoreGotos_2015,basque_AhoySAILRThere_,erosa_TamingControlFlow_1994,kozen_CertificationCompilerOptimizations_2000a}.
And its efficiency, soundness, and completeness allow our works to be invoked automatically on-the-fly, or be used as a framework in a proof assistant.


\section{Efficient Symbolic On-the-fly Algorithm for GKAT}

Although GKAT is extremely efficient in some use cases, its efficiency can be improved in many other scenarios. 
For example, when there is a large amount of primitive test (primitive conditional statements used in if-statement and while-loops), the memory usage and runtime of the original algorithm~\cite{smolka_GuardedKleeneAlgebra_2020} will blowup exponentially. 
The large memory usage is typically resolved using derivatives to produce the automaton on-the-fly~\cite{brzozowski_DerivativesRegularExpressions_1964, schmid_GuardedKleeneAlgebra_2021}, whereas the long runtime can be optimized using symbolic automaton~\cite{pous_SymbolicAlgorithmsLanguage_2015}. 

Our latest work marries these two ideas, and built a theory of symbolic guarded Kleene coalgebra with tests (sGKCT), where we use category theory to streamline some languages in previous works of symbolic automata, and designed an efficient derivative-based symbolic decision procedure for GKAT. 
Unlike similar works on KAT~\cite{pous_SymbolicAlgorithmsLanguage_2015}, the structure of GKAT enables us to export the complex boolean logic into a fast and reliable solvers like z3; further improving the efficiency of our implementation.

This work also characterized the exact complexity of GKAT.





\newpage
\printbibliography %Prints bibliography


\end{document}
